// Generated by CoffeeScript 1.8.0
(function() {
  var G, calculateForceVectors, connectAllPoints, connectPoints, draw, drawVector, generateForceVectors, globals, i, line, move, moveAllPoints, moveRandomPoints, randCoord, randPoint, randPoints, randomForceVector, randomUnitVector, reverseForceVector, _i, _len;

  this.nPoints = 12;

  this.MAXFORCE = 10;

  this.SPEED = .5;

  this.PADDING = 20;

  this.GC = 1;

  globals = ["$window", "$body", "$canvas", "ctx", "size", "Points", "center"];

  for (_i = 0, _len = globals.length; _i < _len; _i++) {
    i = globals[_i];
    this[i] = null;
  }

  G = this;

  this.Connections = [];

  line = function(from, to, color) {
    if (color == null) {
      color = "#000";
    }
    ctx.beginPath();
    ctx.moveTo(from[0], from[1]);
    ctx.lineTo(to[0], to[1]);
    ctx.strokeStyle = color;
    return ctx.stroke();
  };

  this.randDistr = function(distr) {
    var k, n, _j, _len1;
    n = rand(0, 100);
    for (k = _j = 0, _len1 = distr.length; _j < _len1; k = ++_j) {
      i = distr[k];
      if (n <= i) {
        return k;
      }
    }
  };

  this.rand = function(min, max) {
    return min + Math.random() * (max - min);
  };

  this.randint = function(min, max) {
    return Math.floor(rand(min, max + 1));
  };

  randCoord = function(dim) {
    return randint(PADDING, this.size[dim] - PADDING);
  };

  randPoint = function() {
    return [randCoord(0), randCoord(1)];
  };

  connectPoints = function(connsEach) {
    var conn, connsLeft, k, k_, l, _j, _k, _len1, _len2, _results;
    l = Points.length;
    for (k = _j = 0, _len1 = Points.length; _j < _len1; k = ++_j) {
      i = Points[k];
      G.Connections[k] = {
        length: 0
      };
    }
    _results = [];
    for (k = _k = 0, _len2 = Points.length; _k < _len2; k = ++_k) {
      i = Points[k];
      connsLeft = connsEach - G.Connections[k].length;
      console.log(k, connsLeft);
      _results.push((function() {
        var _l, _results1;
        _results1 = [];
        for (k_ = _l = 0; 0 <= connsLeft ? _l < connsLeft : _l > connsLeft; k_ = 0 <= connsLeft ? ++_l : --_l) {
          console.log("try", k, k_);
          if (k === l - 1) {
            break;
          }
          conn = randint(k + 1, l - 1);
          i = 0;
          while (Connections[conn].length >= connsEach || (Connections[k][conn] != null) || (Connections[conn][k] != null)) {
            if (++i > 100) {
              throw "fail";
            }
            conn += 1;
            conn %= l;
          }
          G.Connections[k][conn] = 1;
          G.Connections[k].length++;
          G.Connections[conn][k] = 1;
          _results1.push(G.Connections[conn].length++);
        }
        return _results1;
      })());
    }
    return _results;
  };

  connectAllPoints = function() {
    var j, l, _j, _results;
    l = Points.length;
    _results = [];
    for (i = _j = 0; 0 <= l ? _j < l : _j > l; i = 0 <= l ? ++_j : --_j) {
      G.Connections[i] = {};
      _results.push((function() {
        var _k, _results1;
        _results1 = [];
        for (j = _k = 0; 0 <= l ? _k < l : _k > l; j = 0 <= l ? ++_k : --_k) {
          if (i !== j) {
            _results1.push(G.Connections[i][j] = 1);
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      })());
    }
    return _results;
  };

  randPoints = function(nPoints) {
    var _j;
    G.Points = [];
    for (i = _j = 1; 1 <= nPoints ? _j <= nPoints : _j >= nPoints; i = 1 <= nPoints ? ++_j : --_j) {
      Points.push(randPoint());
    }
    return connectAllPoints();
  };

  randomUnitVector = function() {
    return [randint(-1, 1), randint(-1, 1)];
  };

  generateForceVectors = function() {
    var k, _j, _len1, _results;
    _results = [];
    for (k = _j = 0, _len1 = Points.length; _j < _len1; k = ++_j) {
      i = Points[k];
      _results.push(G.Points[k][2] = randomForceVector());
    }
    return _results;
  };

  calculateForceVectors = function() {
    var d, dim, j, l, sgn, _j, _k, _results;
    l = Points.length;
    _results = [];
    for (i = _j = 0; 0 <= l ? _j < l : _j > l; i = 0 <= l ? ++_j : --_j) {
      G.Points[i][2] = [0, 0];
      for (dim = _k = 0; _k <= 1; dim = ++_k) {
        d = center[dim] - G.Points[i][dim];
        d *= 10;
        sgn = d > 0 ? 1 : -1;
        G.Points[i][2][dim] = sgn * Math.pow(Math.abs(d), 2);
        if (Math.abs(G.Points[i][2][dim]) === Infinity) {
          console.log(d, sgn);
          throw "whaa1";
        }
      }
      _results.push((function() {
        var _l, _results1;
        _results1 = [];
        for (j = _l = 0; 0 <= l ? _l < l : _l > l; j = 0 <= l ? ++_l : --_l) {
          if (i === j) {
            continue;
          }
          _results1.push((function() {
            var _m, _results2;
            _results2 = [];
            for (dim = _m = 0; _m <= 1; dim = ++_m) {
              d = Points[i][dim] - Points[j][dim];
              d /= 10000;
              if (d === 0) {
                d = 1 / 10000;
              }
              sgn = d > 0 ? 1 : -1;
              G.Points[i][2][dim] += sgn * GC / Math.pow(Math.abs(d), 2);
              if (Math.abs(G.Points[i][2][dim]) === Infinity) {
                console.log(d, Math.pow(d, 2.5), Math.pow(Math.abs(d), 2.5), sgn, GC, sgn * GC / Math.abs(Math.pow(d, 2.5)));
                throw "whaa2";
              } else {
                _results2.push(void 0);
              }
            }
            return _results2;
          })());
        }
        return _results1;
      })());
    }
    return _results;
  };

  randomForceVector = function() {
    return [randint(-MAXFORCE, MAXFORCE), randint(-MAXFORCE, MAXFORCE)];
  };

  moveRandomPoints = function(nToMove) {
    var d, k, l, moved, _d, _j, _k, _results;
    moved = {};
    l = Points.length;
    if (nToMove > l) {
      throw "Too many points";
    }
    _results = [];
    for (i = _j = 1; 1 <= nToMove ? _j <= nToMove : _j >= nToMove; i = 1 <= nToMove ? ++_j : --_j) {
      while (true) {
        k = randint(0, l - 1);
        if (moved[k] == null) {
          moved[k] = 1;
          break;
        }
      }
      d = randomUnitVector();
      _results.push((function() {
        var _l, _len1, _results1;
        _results1 = [];
        for (_k = _l = 0, _len1 = d.length; _l < _len1; _k = ++_l) {
          _d = d[_k];
          if (Points[k][_k] >= size[_k] - PADDING) {
            d[_k] = -1;
          } else if (Points[k][_k] <= PADDING) {
            d[_k] = 1;
          }
          _results1.push(Points[k][_k] += d[_k]);
        }
        return _results1;
      })());
    }
    return _results;
  };

  reverseForceVector = function(k) {
    var dim, _j, _len1, _ref, _results;
    _ref = G.Points[k][2];
    _results = [];
    for (dim = _j = 0, _len1 = _ref.length; _j < _len1; dim = ++_j) {
      i = _ref[dim];
      _results.push(G.Points[k][2][dim] = -i);
    }
    return _results;
  };

  drawVector = function(k) {
    var dim, end;
    end = (function() {
      var _j, _results;
      _results = [];
      for (dim = _j = 0; _j <= 1; dim = ++_j) {
        _results.push(Points[k][dim] + Points[k][2][dim] / 10000);
      }
      return _results;
    })();
    return line(Points[k], end, "#FF0000");
  };

  moveAllPoints = function() {
    var d, dim, k, _d, _j, _len1, _results;
    _results = [];
    for (k = _j = 0, _len1 = Points.length; _j < _len1; k = ++_j) {
      i = Points[k];
      _results.push((function() {
        var _k, _len2, _ref, _results1;
        _ref = i[2];
        _results1 = [];
        for (dim = _k = 0, _len2 = _ref.length; _k < _len2; dim = ++_k) {
          _d = _ref[dim];
          if (Points[k][dim] >= size[dim] - PADDING) {
            d = -1;
          } else if (Points[k][dim] <= 20) {
            d = 1;

            /*
            else if rand(0, 1000) < 1
              dim_ = randint 0, 1
              if Points[k][2][dim_] is MAXFORCE
                d = -1
              else if Points[k][2][dim_] is 0
                d = 1
              else
                d = randint 0, 1
                d = -1  if d is 0
              Points[k][2][dim_] += d
             */
          } else {
            d = Points[k][2][dim] * SPEED;
          }
          if (Math.abs(d) > 1) {
            d = Math.sign(d);
          }
          _results1.push(Points[k][dim] += d);
        }
        return _results1;
      })());
    }
    return _results;
  };

  this.lastConn = null;

  draw = function() {
    var conn, k, point, v_, _j, _len1, _results;
    ctx.clearRect(0, 0, size[0], size[1]);
    _results = [];
    for (k = _j = 0, _len1 = Points.length; _j < _len1; k = ++_j) {
      point = Points[k];
      drawVector(k);
      _results.push((function() {
        var _ref, _results1;
        _ref = Connections[k];
        _results1 = [];
        for (conn in _ref) {
          v_ = _ref[conn];
          if (conn === "length") {
            continue;
          }
          if (conn > k) {
            G.lastConn = conn;
            _results1.push(line(point, Points[conn]));
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      })());
    }
    return _results;
  };

  move = function() {
    return window.requestAnimationFrame(function() {
      generateForceVectors();
      moveAllPoints();
      draw();
      return move();
    });
  };

  $(function() {
    G.$window = $(window);
    G.$body = $(document.body);
    G.size = [$window.width(), $window.height()];
    G.size = [240, 240];
    G.center = [size[0] / 2, size[1] / 2];
    randPoints(nPoints);
    G.$canvas = $("<canvas>").attr({
      width: size[0],
      height: size[1]
    }).css({
      display: "block",
      margin: "auto",
      cursor: "pointer"
    });
    G.$canvas.click(function() {
      var nPoints;
      nPoints = Math.floor(Math.random() * 20 + 5);
      return randPoints(nPoints);
    });
    $(".centerer").append($canvas);
    G.ctx = $canvas[0].getContext("2d");
    return move();
  });

}).call(this);
